
   server {
        listen 443 ssl;
        resolver 8.8.8.8;
        lua_ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt ;   
        server_name $host;
        ssl_certificate /etc/openresty/certs/ca.crt;
        ssl_certificate_key /etc/openresty/certs/ca.key; 
       
        ssl_certificate_by_lua_block  {
             local ssl = require "ngx.ssl"
             local addr = ssl.server_name()
             
             local global_key = "/etc/openresty/certs/global.key"
             local global_crt = "/etc/openresty/certs/global.crt"
             local web_server_key = "/etc/openresty/certs/ca.key"
             local web_server_csr = "/etc/openresty/certs/ca.csr"
             local web_server_crt = "/etc/openresty/certs/ca.crt"

            local command_csr  = "openssl req -new -key " .. web_server_key .."  -subj \"/CN=" .. addr .. "/ST=Berlin/C=DE/O=inno2grid GmbH/OU=ems\" -out " .. web_server_csr
            local command_sign = "openssl x509 -req -in " .. web_server_csr .. " -CA " .. global_crt .. " -CAkey  " .. global_key .. " -CAcreateserial -days 360 -out " .. web_server_crt
             
             os.execute(command_csr)
             os.execute(command_sign)
             os.execute("openssl x509 -in /etc/openresty/certs/ca.crt -outform DER -out /etc/openresty/certs/ca_pub.der")
          
             local key_file_path = "/etc/openresty/certs/ca.der"
             local cert_file_path = "/etc/openresty/certs/ca_pub.der" 

             local new_key_file = assert(io.open(key_file_path, "r"))
             local new_key = new_key_file:read("*all")
             new_key_file:close()
       
             local cert_file = assert(io.open(cert_file_path, "r"))
             local cert_content = cert_file:read("*all")
             cert_file:close()
          
             local ok, err = ssl.clear_certs()
          
             local ok, err = ssl.set_der_cert(cert_content)
             if not ok then
                ngx.log(ngx.ERR, "failed to set DER public cert: ", err)
                return ngx.exit(ngx.ERROR)
             end
          
             local ok, err = ssl.set_der_priv_key(new_key)
             if not ok then
                ngx.log(ngx.ERR, "failed to set DER private key: ", err)
                return ngx.exit(ngx.ERROR)
             end    
            }
        location / {
            # default_type 'text/html';
            proxy_ssl_server_name on;
            proxy_ssl_session_reuse on;
            proxy_set_header UPgrade $http_upgrade;
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Forwarded-Host $host:$server_port;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_buffering        on;
            proxy_cache_valid      200  1d;
            proxy_cache_key $scheme://$host$uri$is_args$query_string;
            proxy_cache_bypass $arg_should_bypass_cache;
            http2_push_preload              on;
          
         


          content_by_lua_block {
             local http = require "resty.http"
             local cjson = require "cjson"
             local zlib = require "zlib"

             local httpc = http.new()
             local path = ngx.var.request_uri
             
             local passHeader = {["cookie"]=ngx.req.get_headers()["cookie"]}
             passHeader["content-type"] = ngx.req.get_headers()["content-type"]
             passHeader["X-Forwarded-Proto"] = "https"
             passHeader["X-Forwarded-Host"] = ngx.var.host .. ":443"
             passHeader["X-Real-IP"] = ngx.var.remote_addr
             passHeader["Host"] = ngx.var.host
             passHeader["X-Forwarded-For"] = ngx.var.proxy_add_x_forwarded_for
             passHeader["Accept"] = "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"

             passHeader = ngx.req.get_headers()

             
            ngx.req.read_body();
            local body = ngx.req.get_body_data();
            
            local original_req_uri =  ngx.var.scheme .. "://"  .. ngx.var.host .. path



            local req_method = ngx.req.get_method()


            local res, err = httpc:request_uri(original_req_uri, {
                      method = req_method,
                      keepalive_timeout = 6000,
                      ssl_verify = true,
                      headers = passHeader,
                      keepalive_pool = 10,
                      body = body
                    })


if res then

            local reader = res.body_reader
            local buffer_size = 8192

            repeat
                local buffer, err = reader(buffer_size)
                if err then
                    ngx.log(ngx.ERR, err)
                    break
                end

                if buffer then
                    -- process
                end
            until not buffer


            if res.headers["Content-Encoding"] then
                if res.body and string.find(res.headers["Content-Encoding"], "gzip") then
                    
                    --if string.sub(original_req_uri, -1) == '/' then
                    --    local stream = zlib.inflate()
                    --    local stream_body = stream(res.body)
                    --    local file, err = io.open("/tmp/response.txt", "w")
                    --    local success, err = file:write(stream_body)
                    --    file:close()
                    -- end
                    print ("gzip block")
                else
                    --if string.sub(original_req_uri, -1) == '/' then
                    --    local file, err = io.open("/tmp/response.txt", "w")
                    --    local success, err = file:write(res.body)
                    --    file:close()
                    --end
                    print (" block")
                end

            end
end
            for k, v in pairs(res.headers) do
                ngx.header[k] = v
            end


            ngx.status = res.status
            ngx.print(res.body)
            -- local modifiedString = string.gsub(streamResonse, "Kriminal", "HACKed")
            --ngx.print (modifiedString)
            }
       }    
    }
